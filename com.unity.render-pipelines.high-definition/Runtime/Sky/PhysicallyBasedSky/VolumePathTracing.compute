#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightDefinition.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/AtmosphericScattering/AtmosphericScattering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/CookieSampling.hlsl"

#define DEBUG

#define MAKE_FLT(sgn, exponent, fraction) asfloat((((sgn) & 0x1) << 31) | (((exponent) & 0xFF) << 23) | ((fraction) & 0xFFFFFF))
#define FLT_SNAN MAKE_FLT(0x1, 0xFF, 0x1)
#ifdef DEBUG
    #define ASSERT(x) if (!(bool)(x)) return FLT_SNAN
#else  // DEBUG
    #define ASSERT(x) x
#endif // DEBUG

static const uint s_RandomPrimes[10] = { 0xD974CF83, 0xFAF269B5, 0xAE727FA9, 0x5BA52335, 0xA4E819D5, 0xDD638559, 0xC0972367, 0x4B190D9B, 0xD1894DB5, 0xA78BCBB3 };

TEXTURECUBE(_GroundAlbedoTexture);
TEXTURECUBE(_GroundEmissionTexture);
TEXTURECUBE(_SpaceEmissionTexture);

RW_TEXTURE2D_X(float4, _ColorBuffer);

int _HasGroundAlbedoTexture;    // bool...
int _HasGroundEmissionTexture;  // bool...
int _HasSpaceEmissionTexture;   // bool...
int _RenderSunDisk;             // bool...

float _GroundEmissionMultiplier;
float _SpaceEmissionMultiplier;
uint  _DispatchThreadCount;
uint  _PassIndex;
uint  _BounceCount;

// 3x3, but Unity can only set 4x4...
float4x4 _PlanetRotation;
float4x4 _SpaceRotation;

struct Ray
{
    float3 origin;
    float3 direction;
    float  frequency;
};

// 'l' is the size of the permutation vector (e.g. the number of strata per dimension).
uint permute(uint i, uint l, uint p)
{
    ASSERT(l != 0);

    if (p == 0) return i; // Identity permutation when (p == 0)

    uint w = l - 1;

    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;
    do
    {
        i ^= p; i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8; i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1; i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11; i *= 0x74dcb303;
        i ^= (i & w) >> 2;  i *= 0x9e501cc3;
        i ^= (i & w) >> 2;  i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);

    return (i + p) % l;
}

float randfloat(uint i, uint p)
{
    if (p == 0) return 0.5f; // always 0.5 when (p == 0)

    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10; i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21; i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17; i *= 1 | p >> 18;

    float f = i * (1.0f / 4294967808.0f);

    ASSERT(0 <= f && f < 1);

    return f;
}

// Multi-dimensional correlated multi-jittered sequence.
// We specialize it for 6D, which means we generate s^6 points.
float cmj6D(uint pointIndex, uint dimIndex, uint seed)
{
    dimIndex = dimIndex % (6 - 1);

    const uint s = 4;           // Number of strata per dimension
    const uint t = 6;           // Strength of the orthogonal array (number of dimensions)
    const uint n = 4096;        // Size of the sequence: n = s^t
    const uint p = seed;        // Pseudo-random permutation seed
    const uint i = permute(pointIndex, n, p); // Shuffle the points
    const uint j = dimIndex;

    ASSERT(i < n);
    ASSERT(j < t);

    const uint p1 = (p * (j + 1)) * 0x51633e2d;
    const uint p2 = (p * (j + 1)) * 0x68bc21eb;
    const uint p3 = (p * (j + 1)) * 0x02e5be93;

    uint digits[t];

    uint d; // Avoid compiler warning

    uint k = i;

    // digits = toBaseS(i, s);
    for (d = 0; d < t; k /= s, d++)
    {
        digits[d] = k % s;
    }

    uint stratum = permute(digits[j], s, p1);

    // digits = allButJ(digits, j);
    for (d = j + 1; d < t; d++)
    {
        digits[d - 1] = digits[d];
    }

    uint poly = 0;

    // poly = evalPoly(digits, s);
    for (d = (t - 2); d != uint(-1); d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }

    uint  stm      = n / s; // pow(s, t - 1)
    uint  sStratum = permute(poly, stm, p2);
    float jitter   = randfloat(i, p3);

    return (stratum + (sStratum + jitter) / stm) / s;
}

#define GROUP_SIZE_1D 8 // 8^2 == 64
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define BLOCK_SIZE_1D 4 // 4^2 == 16

// Map: 0 1 -> (0,0) (1,0)
//      2 3 -> (0,1) (1,1)
uint2 zSwizzle(uint v)
{
    return uint2(v & 1, (v >> 1) & 1); // Will also truncate the input to 2 bits
}

// 1x path per thread per call.
// Tracing multiple paths can be achieved via multiple passes (0 <= passIndex < 256).
// Do not access globals from within a pure function.
float3 PathTraceSky(uint2 groupCoord, uint dispatchThreadIndex, uint dispatchThreadCount,
                    uint groupSize1D, uint blockSize1D, uint bounceCount, uint passIndex,
                    float3 rayOrigin, out uint2 positionSS)
{
    uint blockSize2D    = blockSize1D * blockSize1D;
    uint blocksPerGroup = Sq(groupSize1D / blockSize1D);

    ASSERT(blocksPerGroup == 4);

    // Integral over ((1 + NumBounces) * 3) dimensions:
    // 2x for filter IS + 1x for photon frequency selection (bounce #0);
    // 1x for scattering location + 2x for the scattering direction (bounce #i).
    uint dimCount = bounceCount * 3 + 3;

    // We constrain our RNG to 6 dimensions.
    // We generate 4096 (4^6) paths stratified into 4 intervals per dimension.
    // That gives us 256 spp within a 4x4 block of pixels.
    // The stratification properties of Orthogonal Arrays guarantee 256 spp, but make no promises
    // about the uniformity of the distribution within each individual pixel (or stratum).
    // As for the order of generated points, every single pass produces 1spp on average,
    // but this could mean several samples for one pixel and 0 for another.
    // Therefore, we must use atomics for accumulation.
    uint blockIndex       = dispatchThreadIndex / blockSize2D;
    uint blockCount       = dispatchThreadCount / blockSize2D;
    uint blockThreadIndex = dispatchThreadCount % blockSize2D;

    // We generate a unique point set per block every 2 bounces.
    uint   bounce     = 0;
    uint   seed       = permute(blockIndex, blockCount, s_RandomPrimes[bounce / 2]); // Shuffle the blocks
    uint   pointIndex = blockSize2D * passIndex + blockThreadIndex; // Block of points per pass
    float3 rnd        = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                               cmj6D(pointIndex, bounce * 3 + 1, seed),
                               cmj6D(pointIndex, bounce * 3 + 2, seed));

    // Determine which pixel the path contributes to.
    float2 filterOffset = rnd.xy; // TODO: do not use a box filter?
    float2 screenCoord  = groupSize1D * groupCoord
                        + blockSize1D * zSwizzle(blockIndex) // Assume 4 blocks per group
                        + blockSize1D * filterOffset;

    positionSS = (uint2)screenCoord;

    Ray ray; // Pinhole camera...

    // Point away from the camera into the scene.
    ray.direction = -normalize(mul(float4(screenCoord, 1, 1), _PixelCoordToViewDirWS).xyz);
    ray.origin    = rayOrigin;
    ray.frequency = floor(rnd.z * 3); // Color channel, for now...

    // for (bounce = 1; bounce < bounceCount; bounce++)
    // {
    //     seed = permute(pathIndex, numPaths, s_RandomPrimes[bounce / 2]);
    //     rnd  = float3(cmj6D(threadIndex, (bounce * 3 + 0) % 5, seed),
    //                   cmj6D(threadIndex, (bounce * 3 + 1) % 5, seed),
    //                   cmj6D(threadIndex, (bounce * 3 + 2) % 5, seed));


    // }

    const float  R = _PlanetaryRadius;

    return 1;
}

// Floating-point atomics are not supported. Use fixed-point math in units of HALF_MIN instead.
groupshared uint g_RadianceR[GROUP_SIZE_2D];
groupshared uint g_RadianceG[GROUP_SIZE_2D];
groupshared uint g_RadianceB[GROUP_SIZE_2D];
groupshared uint g_SampleCount[GROUP_SIZE_2D];

[numthreads(GROUP_SIZE_2D, 1, 1)]
void main(uint2 groupCoord       : SV_GroupID,
          uint  groupIndex       : SV_GroupIndex,
          uint  groupThreadIndex : SV_GroupThreadID)
{
    // SV_DispatchThreadID is 2D in our case, and that's not what we want.
    uint dispatchThreadIndex = groupIndex * GROUP_SIZE_2D + groupThreadIndex;

    const float3 origin = _WorldSpaceCameraPos - _PlanetCenterPosition;

    uint2  outPositionSS;
    float3 radiance = PathTraceSky(groupCoord, dispatchThreadIndex, _DispatchThreadCount,
                                   GROUP_SIZE_1D, BLOCK_SIZE_1D, _BounceCount, _PassIndex,
                                   origin, outPositionSS);

    // Find the corresponding coordinate in the groupshared memory.
    uint outPositionGS = (outPositionSS.y % GROUP_SIZE_1D) * GROUP_SIZE_1D
                       + (outPositionSS.x % GROUP_SIZE_1D);

    // Full clear.
    g_RadianceR[groupThreadIndex]   = 0;
    g_RadianceG[groupThreadIndex]   = 0;
    g_RadianceB[groupThreadIndex]   = 0;
    g_SampleCount[groupThreadIndex] = 0;
    // Partial fill.
    GroupMemoryBarrierWithGroupSync();
    InterlockedAdd(g_RadianceR[outPositionGS], round(radiance.r * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceG[outPositionGS], round(radiance.g * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceB[outPositionGS], round(radiance.b * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceB[outPositionGS], 1);
    // Full load.
    uint sampleCount;
    GroupMemoryBarrierWithGroupSync();
    radiance.r    = g_RadianceR[groupThreadIndex] * rcp(16384);
    radiance.g    = g_RadianceG[groupThreadIndex] * rcp(16384);
    radiance.b    = g_RadianceB[groupThreadIndex] * rcp(16384);
    sampleCount   = g_SampleCount[groupThreadIndex];
    outPositionSS = GROUP_SIZE_1D * groupCoord + uint2(groupThreadIndex % GROUP_SIZE_1D, groupThreadIndex / GROUP_SIZE_1D);

    // We store the sample count in the alpha channel.
    float3 oldRadiance    = _ColorBuffer[COORD_TEXTURE2D_X(outPositionSS)].rgb;
    float  oldSampleCount = _ColorBuffer[COORD_TEXTURE2D_X(outPositionSS)].a;
    float  newSampleCount = oldSampleCount + sampleCount;
    float4 newValue       = float4((oldRadiance * oldSampleCount + radiance) * rcp(max(newSampleCount, 1)), newSampleCount);
    _ColorBuffer[COORD_TEXTURE2D_X(outPositionSS)] = newValue;
}
