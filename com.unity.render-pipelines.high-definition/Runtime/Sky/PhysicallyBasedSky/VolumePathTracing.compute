#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightDefinition.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/AtmosphericScattering/AtmosphericScattering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/CookieSampling.hlsl"

#define DEBUG

#define MAKE_FLT(sgn, exponent, fraction) asfloat((((sgn) & 0x1) << 31) | (((exponent) & 0xFF) << 23) | ((fraction) & 0xFFFFFF))
#define FLT_SNAN MAKE_FLT(0x1, 0xFF, 0x1)
#ifdef DEBUG
    #define ASSERT(x) if (!(bool)(x)) return FLT_SNAN
#else  // DEBUG
    #define ASSERT(x) x
#endif // DEBUG

static const uint s_RandomPrimes[10] = { 0xD974CF83, 0xFAF269B5, 0xAE727FA9, 0x5BA52335, 0xA4E819D5, 0xDD638559, 0xC0972367, 0x4B190D9B, 0xD1894DB5, 0xA78BCBB3 };

TEXTURECUBE(_GroundAlbedoTexture);
TEXTURECUBE(_GroundEmissionTexture);
TEXTURECUBE(_SpaceEmissionTexture);

RW_TEXTURE2D_X(float4, _ColorBuffer);

int _HasGroundAlbedoTexture;    // bool...
int _HasGroundEmissionTexture;  // bool...
int _HasSpaceEmissionTexture;   // bool...
int _RenderSunDisk;             // bool...

float _GroundEmissionMultiplier;
float _SpaceEmissionMultiplier;
uint  _DispatchThreadCount;
uint  _DispatchWidth;
uint  _PassIndex;
uint  _BounceCount;

// 3x3, but Unity can only set 4x4...
float4x4 _PlanetRotation;
float4x4 _SpaceRotation;

struct Ray
{
    float3 origin;
    float3 direction;
    float  frequency;
    float  maxDist;
};

// 'l' is the length of the permutation vector (e.g. the number of strata per dimension).
uint permute(uint i, uint l, uint p)
{
    ASSERT(l != 0);

    if (p == 0) return i; // Identity permutation when (p == 0)

    uint w = l - 1;

    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;
    do
    {
        i ^= p; i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8; i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1; i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11; i *= 0x74dcb303;
        i ^= (i & w) >> 2;  i *= 0x9e501cc3;
        i ^= (i & w) >> 2;  i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);

    return (i + p) % l;
}

float randfloat(uint i, uint p)
{
    if (p == 0) return 0.5f; // always 0.5 when (p == 0)

    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10; i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21; i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17; i *= 1 | p >> 18;

    float f = i * (1.0f / 4294967808.0f);

    ASSERT(0 <= f && f < 1);

    return f;
}

// Multi-dimensional correlated multi-jittered sequence.
// We specialize it for 6D, which means we generate s^6 points.
float cmj6D(uint pointIndex, uint dimIndex, uint seed)
{
    dimIndex = dimIndex % (6 - 1);

    const uint s = 4;           // Number of strata per dimension
    const uint t = 6;           // Strength of the orthogonal array (number of dimensions)
    const uint n = 4096;        // Size of the sequence: n = s^t
    const uint p = seed;        // Pseudo-random permutation seed
    const uint i = permute(pointIndex, n, p); // Shuffle the points
    const uint j = dimIndex;

    ASSERT(i < n);
    ASSERT(j < t);

    const uint p1 = (p * (j + 1)) * 0x51633e2d;
    const uint p2 = (p * (j + 1)) * 0x68bc21eb;
    const uint p3 = (p * (j + 1)) * 0x02e5be93;

    // TODO: we do not actually need 't' registers.
    // The compiler should be able to fuse the loops below.
    // This formulation is retained for comparison with the reference implementation.
    uint digits[t];

    uint k = i, d = 0;

    // digits = toBaseS(i, s);
    for (d = 0; d < t; k /= s, d++)
    {
        digits[d] = k % s;
    }

    uint stratum = permute(digits[j], s, p1);

    uint poly = 0;

    // digits = allButJ(digits, j);
    // poly   = evalPoly(digits, s);
    for (d = (t - 1); d != j; d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }
    for (d = (j - 1); d != uint(-1); d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }

    uint  stm      = n / s; // pow(s, t - 1)
    uint  sStratum = permute(poly, stm, p2);
    float jitter   = randfloat(i, p3);
    float result   = (stratum + (sStratum + jitter) / stm);

    return result / s;
}

#define GROUP_SIZE_1D 8 // 8^2 == 64
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define TILE_SIZE_1D  4 // 4^2 == 16

// 1x path per thread per call.
// Tracing multiple paths can be achieved via multiple passes (0 <= passIndex < 256).
// Do not access globals from within a pure function.
float3 PathTraceSky(uint2 groupCoordInDispatch, uint groupIndexInDispatch,
                    uint2 threadCoordInGroup, uint threadCountInDispatch,
                    uint groupSize1D, uint tileSize1D, uint bounceCount, uint passIndex,
                    float3 rayOrigin, out uint2 positionSS)
{
    uint tileSize2D      = tileSize1D * tileSize1D;
    uint tilesPerGroup1D = groupSize1D / tileSize1D;
    uint tilesPerGroup2D = Sq(tilesPerGroup1D);

    // Integral over ((1 + NumBounces) * 3) dimensions:
    // 2x for filter IS + 1x for photon frequency selection (bounce #0);
    // 1x for scattering location + 2x for the scattering direction (bounce #i).
    uint dimCount = bounceCount * 3 + 3;

    // We constrain our RNG to 6 dimensions.
    // We generate 4096 (4^6) paths stratified into 4 intervals per dimension.
    // That gives us 256 spp within a 4x4 tile of pixels.
    // The stratification properties of Orthogonal Arrays guarantee 256 spp, but make no promises
    // about the uniformity of the distribution within each individual pixel (or stratum).
    // TODO: it seems we get between 249-257 spp. Floating-point issue?
    // As for the order of generated points, every single pass produces 1spp on average,
    // but this could mean several samples for one pixel and 0 for another.
    // Therefore, we must use atomics for accumulation.
    uint2 tileCoordInGroup    = threadCoordInGroup / tileSize1D;
    uint  tileIndexInGroup    = tileCoordInGroup.y * tilesPerGroup1D + tileCoordInGroup.x;
    uint  tileIndexInDispatch = groupIndexInDispatch * tilesPerGroup2D + tileIndexInGroup;
    uint  tileCountInDispatch = threadCountInDispatch / tileSize2D;
    uint2 threadCoordInTile   = threadCoordInGroup % tileSize1D;
    uint  threadIndexInTile   = threadCoordInTile.y * tileSize1D + threadCoordInTile.x;

    // We generate a unique point set per tile every 2 bounces.
    uint   bounce     = 0;
    uint   seed       = permute(tileIndexInDispatch, tileCountInDispatch, s_RandomPrimes[bounce / 2]); // Shuffle the tiles
    uint   pointIndex = tileSize2D * passIndex + threadIndexInTile; // Tile of points per pass
    float3 rnd        = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                               cmj6D(pointIndex, bounce * 3 + 1, seed),
                               cmj6D(pointIndex, bounce * 3 + 2, seed));

    // Determine which pixel the path contributes to.
    float2 filterOffset    = rnd.xy; // TODO: do not use a box filter?
    float2 intraTileOffset = filterOffset * tileSize1D;

    positionSS = groupSize1D * groupCoordInDispatch
               + tileSize1D  * tileCoordInGroup
               + (uint2)intraTileOffset;

    float2 screenCoord = positionSS + frac(intraTileOffset);

    Ray ray; // Pinhole camera...

    // Point away from the camera into the scene.
    ray.direction = -normalize(mul(float4(screenCoord, 1, 1), _PixelCoordToViewDirWS).xyz);
    ray.origin    = rayOrigin;
    ray.frequency = floor(rnd.z * 3); // Color channel, for now...

    // Our atmosphere, theoretically, extends to infinity but, numerically,
    // its density exponentially falls off to zero pretty quickly.
    const float A = _AtmosphericRadius;
    const float R = _PlanetaryRadius;

    // Parametrize the ray interval between two points X and Y.
    float rX, rSqX, rRcpX, cosChiX;
    ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ rX, rSqX, rRcpX, cosChiX);

    float2 atmosEntryExit = IntersectSphere(A, cosChiX, rX, rRcpX);
    bool   hitAtmosphere  = atmosEntryExit.y > 0;

    if (!hitAtmosphere)
    {
        return 0; // TODO: sample the space emission texture.
    }

    // Do not path trace outside the atmosphere.
    if (atmosEntryExit.x > 0)
    {
        ray.origin += atmosEntryExit.x * ray.direction;
        // Careful: we may end up on the edge of the atmosphere and, numerically, outside.
        ray.origin *= (1 - 1e-6); // 2 orders of magnitude larger than FLT_EPS

        // Update ray parameters.
        ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ rX, rSqX, rRcpX, cosChiX);

        atmosEntryExit.y -= atmosEntryExit.x;
        atmosEntryExit.x  = 0;
    }

    float cosHorX      = ComputeCosineOfHorizonAngle(rRcpX);
    bool  aboveHorizon = (cosChiX >= cosHorX);

    if (aboveHorizon)
    {
        ray.maxDist = atmosEntryExit.y;
    }
    else
    {
        ray.maxDist = IntersectSphere(R, cosChiX, rX, rRcpX).x; // Entry
        ASSERT(ray.maxDist > 0);
    }


    for (bounce = 1; bounce < bounceCount; bounce++)
    {

    }

    return 1 - saturate(ray.maxDist / 10000);
}

// Floating-point atomics are not supported. Use fixed-point math in units of HALF_MIN instead.
groupshared uint g_RadianceR[GROUP_SIZE_2D];
groupshared uint g_RadianceG[GROUP_SIZE_2D];
groupshared uint g_RadianceB[GROUP_SIZE_2D];
groupshared uint g_SampleCnt[GROUP_SIZE_2D];

[numthreads(GROUP_SIZE_1D, GROUP_SIZE_1D, 1)]
void main(uint2 groupCoordInDispatch  : SV_GroupID,
          uint2 threadCoordInGroup    : SV_GroupThreadID,
          uint  threadIndexInGroup    : SV_GroupIndex,
          uint2 threadCoordInDispatch : SV_DispatchThreadID)
{
    if (_PassIndex > 255) return;

    const uint groupIndexInDispatch = groupCoordInDispatch.y * _DispatchWidth + groupCoordInDispatch.x;

    // Planet-relative coordinates.
    const float3 origin = _WorldSpaceCameraPos - _PlanetCenterPosition;

    uint2  outPositionSS;
    float3 radiance = PathTraceSky(groupCoordInDispatch, groupIndexInDispatch,
                                   threadCoordInGroup, _DispatchThreadCount,
                                   GROUP_SIZE_1D, TILE_SIZE_1D, _BounceCount, _PassIndex,
                                   origin, outPositionSS);

    // Find the corresponding coordinate in the groupshared memory.
    uint outPositionGS = (outPositionSS.y % GROUP_SIZE_1D) * GROUP_SIZE_1D
                       + (outPositionSS.x % GROUP_SIZE_1D);

    // Full clear.
    g_RadianceR[threadIndexInGroup] = 0;
    g_RadianceG[threadIndexInGroup] = 0;
    g_RadianceB[threadIndexInGroup] = 0;
    g_SampleCnt[threadIndexInGroup] = 0;
    // Partial fill.
    GroupMemoryBarrierWithGroupSync();
    InterlockedAdd(g_RadianceR[outPositionGS], round(radiance.r * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceG[outPositionGS], round(radiance.g * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceB[outPositionGS], round(radiance.b * 16384)); // Fixed-point
    InterlockedAdd(g_SampleCnt[outPositionGS], 1);
    // Full load.
    uint sampleCount;
    GroupMemoryBarrierWithGroupSync();
    radiance.r  = g_RadianceR[threadIndexInGroup] * rcp(16384);
    radiance.g  = g_RadianceG[threadIndexInGroup] * rcp(16384);
    radiance.b  = g_RadianceB[threadIndexInGroup] * rcp(16384);
    sampleCount = g_SampleCnt[threadIndexInGroup];

    // We store the sample count in the alpha channel.
    float3 oldRadiance    = _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].rgb;
    float  oldSampleCount = round(_ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].a);
    float  newSampleCount = oldSampleCount + sampleCount;
    float4 newValue       = float4((oldRadiance * oldSampleCount + radiance) * rcp(max(newSampleCount, 1)), newSampleCount);
    _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)] = newValue;
}
